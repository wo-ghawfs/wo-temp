# wo-templates
# GitHub Actions Workflow Documentation for workload-orchestration

## Overview

This repository contains GitHub Actions workflows that automate various Azure Arc Workload Orchestation operations. 

- **wo_infra_deploy**: automates the setup and deployment of sites, targets and service groups and ready it for application deployments
- **wo_cm_onboarding**: automates the process of creating workload orchestration ARM artifacts from configurations for multiple applications
- **wo_solution_deploy**: automates the process of configuration, publish and deployment of solutions across multiple targets
- **wo_syncversion**: automates the sync'ing version of wo artifacts with the application Helm Chart version
- **wo_pullreq**: automates the process of identifying all the changed files in a pull-request and optionally validating them

## Initial Setup

Before using these workflows, you need to configure Azure authentication using a User-Assigned Managed Identity (UAMI) and federated identity credentials.

### ðŸ” Configure Federated Identity Credential for GitHub Actions (Azure Portal)

This guide walks you through configuring a **federated identity credential** in the **Azure Portal** so your GitHub Actions workflows can authenticate to Azure using a **User-Assigned Managed Identity (UAMI)** â€” without storing secrets.

> Based on [Microsoft Learn documentation](https://learn.microsoft.com/en-us/entra/workload-id/workload-identity-federation-create-trust-user-assigned-managed-identity)

#### Prerequisites

- An existing **User-Assigned Managed Identity (UAMI)** in Azure
- A GitHub repository
- Access to the **Azure Portal**
- Contributor or Owner access to relevant Azure resources

#### Step-by-Step Instructions

##### 1. Open the Managed Identity in Azure Portal

1. Go to [https://portal.azure.com](https://portal.azure.com)
2. In the top search bar, type **User assigned identities**
3. Select your UAMI from the list

#####  2. Add a Federated Identity Credential

1. In the UAMI's left-hand Settings menu, click **Federated credentials**
2. Click **+ Add credential**
3. Fill in the required fields:

| Field | Value |
|-------|-------|
| **Federated credential scenario** | Github Actions deploying Azure resources
| **Issuer** | `https://token.actions.githubusercontent.com` |
| **Subject identifier** | `repo:<OWNER>/<REPO>:ref:refs/heads/<BRANCH>` <br> Automatically set when Git account details are provided. |
| **Name** | `github-actions` or something descriptive |
| **Audience** | `api://AzureADTokenExchange` (default) |

4. Click **Add**

> You can create multiple credentials for different repos or branches.

##### 3. Assign Azure Role to the UAMI

1. Navigate to the Azure **resource** or **resource group** your workflow will access
2. Open **Access control (IAM)** â†’ Click **+ Add > Add role assignment**
3. Choose a role, select your UAMI, and then click **Save**

You will need to assign the identity the contributor role at a subscription level.

#### ðŸ” Save GitHub Secrets

To authenticate from your GitHub Actions workflow, you'll need to store the following Azure values as **GitHub repository secrets**.

1. In your repository, go to **Settings**  
2. Click **Secrets and variables â†’ Actions**
3. Click **New repository secret**
4. Add the following secrets:

| Name | How to Find It |
|------|----------------|
| `AZURE_CLIENT_ID` | In the UAMI's **Overview â†’ Client ID** |
| `AZURE_TENANT_ID` | From **Microsoft Entra ID â†’ Overview â†’ Tenant ID** |
| `AZURE_SUBSCRIPTION_ID` | From **Subscriptions â†’ Overview â†’ Subscription ID** |
|

> ðŸ”’ Secrets are encrypted and only available to GitHub Actions workflows.

## Repository Layout

The workflows are configured to work with the following repo folder structure organization

### 

* **apps**
  * testapp1
    * helm
      * Chart.yaml
      * ... other app files
    * workload-orchestration
      * schemas/
        * schema.yaml *(template file - used by workflow, not deployed)*
        * 1.0.0/
          * testapp1-schema.yaml *(deployed to Azure)*
        * 2.0.0/
          * testapp1-schema.yaml *(deployed to Azure)*
      * solution-templates/
        * sol-template.yaml *(template file - used by workflow, not deployed)*
        * 1.0.0/
          * testapp1-sol-template.yaml *(deployed to Azure)*
        * 2.0.0/
          * testapp1-sol-template.yaml *(deployed to Azure)*
      * testapp1-specs.json
      * metadata.yaml
    * solutions/
      * testapp1-solution.yaml *(generated by workflow)*
      * solution-target-configs.yaml
      * defaultbaseconfig.yaml
      * deployments.yaml
  * testapp2
    * helm
      * Chart.yaml
      * ... other app files
    * workload-orchestration
      * schemas/
        * schema.yaml *(template file - used by workflow, not deployed)*
        * 1.0.0/
          * testapp2-schema.yaml *(deployed to Azure)*
        * 2.0.0/
          * testapp2-schema.yaml *(deployed to Azure)*
      * solution-templates/
        * sol-template.yaml *(template file - used by workflow, not deployed)*
        * 1.0.0/
          * testapp2-sol-template.yaml *(deployed to Azure)*
        * 2.0.0/
          * testapp2-sol-template.yaml *(deployed to Azure)*
      * testapp2-specs.json
      * metadata.yaml
    * solutions/
      * testapp2-solution.yaml *(generated by workflow)*
      * solution-target-configs.yaml
      * defaultbaseconfig.yaml
      * deployments.yaml

  * common
    * schemas/
      * schema.yaml *(template file - used by workflow, not deployed)*
      * 1.0.0/
        * common-schema.yaml *(deployed to Azure)*
      * 2.0.0/
        * common-schema.yaml *(deployed to Azure)*
    * config-templates/
      * config-template.yaml *(template file - used by workflow, not deployed)*
      * 1.0.0/
        * common-config-template.yaml *(deployed to Azure)*
      * 2.0.0/
        * common-config-template.yaml *(deployed to Azure)*
    * solutions/
      * common-config-temp.yaml *(generated by workflow)*
* **sites**
  * common
    * wo-common.yaml
    * capabilities.json
  * albany
    * custom-location.json
    * target.yaml
    * wo-site.yaml
    * targetspecs.json
  * bethel
    * target.yaml
    * wo-site.yaml
    * targetspecs.json
    * custom-location.json
  * tanzu
    * custom-location.json
    * target.yaml
    * wo-site.yaml
    * targetspecs.json
  * etc 

### File Structure Explanation

#### *APPS*

The workload orchestration structure uses a two-tiered approach:

1. **Template Files** (root level): Used by GitHub Actions workflows for generating versioned files
   - `schemas/schema.yaml` - Schema template used to generate versioned schema files
   - `solution-templates/sol-template.yaml` - Solution template used to generate versioned template files
   - These files are **not deployed to Azure** directly

2. **Versioned Files** (in version subdirectories): The actual files deployed to Azure
   - `schemas/1.0.0/app-schema.yaml` - Deployed schema for version 1.0.0
   - `solution-templates/1.0.0/app-sol-template.yaml` - Deployed solution template for version 1.0.0
   - Each version maintains its own copy for tracking and rollback purposes

3. **Generated Files** (solutions directory): Created by workflows during deployment process
   - Configuration templates and other artifacts generated during the CI/CD process

#### *SITES/TARGETS*

The sites/ folder is used to configure details for different sites and end targets 

- `wo-site.yaml`         : Used to specify the site/plant details
- `target.yaml`          : Used to specify end target details - names, capabilities etc
- `custom-location.json` : Auto-updated with the custom-location details of the site
- `targetspecs.json`     : Defines the site characteristics to process solution types

#### *SOLUTIONS*

The solutions/ folder is used to configure the solutions to be deployed to one or more targets

- `testapp-solution.yaml`        : This file is auto-generated and retain details of current solutions and their versions
- `solution-target-configs.yaml` : This file contains the target level configurations for each solution version
- `defaultbaseconfig`            : This file is used to maintain a default set of associated target config values.
                                   The solution-target-configs file can be used to override specific values for each target
- `deployments.yaml`             : This file will drive the deployment flow 


## WORKFLOWS

## wo_infra_deploy

This workflow is intended to help with the initial setup of workload orchestration, which includes creating a custom location, downloading the workload orchestration extension,
and installing the required components. It includes set up of the Azure resources for workload orchestration, including the Azure Kubernetes Service (AKS) cluster.

Optionally, the workflow can also be used to setup service groups and the targets on a per site basis.

All the configurations and data for setup are sourced from the respective files maintained in a hierarchical folder structure as previously shown.

```mermaid
graph TD
    A[ Manual Trigger w/Options] --> | Options | B[Site or SGs or Targets]
    B --> |Select Site| C{Parse Selection}
    C --> |Site| D[WO ready Site]
    C --> |SGs| E[Setup SGs]
    C --> |Targets| F[Setup Targets]
    D --> G{All deployed ?}
    E --> G
    F --> G
    G --> |  w-o ready | H[Ready for Soln Deployments]
```

## wo_syncversion

This is an optional workflow that is used to detect any all application Helm Chart commits via push to the main branch. 

The intent of the workflow is to update and sync all the workload orchestration artifacts (schemas, solution templates) in sync with the Helm Chart version.
While not necessary to function, it will help with maintainability and much eaiser tracking of versioning across all artifacts of a given solution or usecase.

```mermaid
graph TD
    A[ Push to main ] --> | auto | B[Loop Through Changed Files]
    B --> C{app Helm Chart changed ?}
    C --> |Yes| D[Update schema,sol-template versions]
    C --> |No| F
    D --> F[process next file changed]
```

## wo_solution_deploy

This workflow is intended to help with configuration, publish and deployment of a solution across target(s) with Git based configurations

All the configurations are maintained in a hierarchical folder structure on a per solution per target basis.

Note: The capabilities of solutions and targets are matched before attempting any deployment.

```mermaid
graph TD
    A[ Push to main] --> | auto | B[Process deployments.yaml]
    B --> C{deployments requested ?}
    C --> |Yes| D[Loop through deployment entries]
    C --> |No| H[Done]
    D --> F{matching capabilities?}
    F --> |Yes| G[configure,publish & deploy]
    G --> H
    G --> D
```

## wo_pullreq

This is another optional workflow that may be used to detect and optionally validate/verify proposed PR changes. 

It is auto-triggered when a PR is opened against the main branch. Optionally, commits to specific folder/dir may be used as triggers.

```mermaid
graph TD
    A[ PR for main ] --> | auto | B[Loop Through Changed Files]
    B --> |per file| C[Validate w/ tests]
    C --> D{all good ?}
    D --> |yes| E[process next file changed]
    D --> |no| F[Mark failed. Stop]
```

## wo_autoversion

```mermaid
graph TD
    A[Push to main/.pg/**] --> B[Detect Apps to Update]
    C[Manual Trigger w/Options] --> B
    B --> |Matrix Strategy| D[Update Job Per App]
    D --> E[Azure Login]
    E --> F[Install WO Extension]
    F --> G[Get App Files]
    
    subgraph File Processing
        G --> H[Check Changed Files]
        H --> I{Update Type}
        I -->|Schema| J[Create/Update Schema]
        I -->|Template| K[Create/Update Solution Template]
    end
```

## File Structure

```mermaid
graph TD
    A[.pg/] --> B[apps/]
    B --> C[testapp1/]
    C --> D[helm/]
    C --> E[workload-orchestration/]
    C --> F[solutions/]
    E --> G[schemas/]
    E --> H[solution-templates/]
    G --> I[1.0.0/]
    G --> J[2.0.0/]
    H --> K[1.0.0/]
    H --> L[2.0.0/]
```

### Required Files

Each application directory requires these files in its `workload-orchestration` directory:

#### Template Files (used by workflow, not deployed):
1. `schemas/schema.yaml`: Template for generating versioned schema files
2. `solution-templates/sol-template.yaml`: Template for generating versioned solution template files
3. `solution-templates/specs.json`: Deployment specifications (referenced by solution templates)
4. `metadata.yaml`: Contains metadata like capabilities and external validation settings

#### Versioned Files (deployed to Azure):
1. `schemas/1.0.0/*-schema.yaml`: Versioned schema files deployed to Azure
2. `solution-templates/1.0.0/*-sol-template.yaml`: Versioned solution template files deployed to Azure
3. `solution-templates/1.0.0/*-specs.yaml`: Versioned solution template files deployed to Azure
4. Each version (1.0.0, 2.0.0, etc.) maintains its own copy for tracking and rollback

#### Generated Files:
1. `solutions/*-config-temp.yaml`: Configuration templates generated during workflow execution

Note: The `*` in filenames represents any prefix specific to your app.

## Trigger Comparison

### Automatic (Push) Trigger
- **When**: Activates on push to main branch
- **Files**: Only processes changed files in `.pg/**/workload-orchestration/**`
- **App Detection**: Automatically detects apps from changed file paths
- **Actions**:
  * Creates/updates schema if schema file changed
  * Creates/updates template if any of these changed:
    - Template file
    - Specs file
    - Metadata file
- **Validation**: Directory existence checked automatically
- **Parallel**: Processes all detected apps concurrently (max 4)

### Manual (Workflow Dispatch) Trigger
- **When**: Manually triggered via GitHub Actions UI
- **Files**: Processes all files for specified apps
- **App Selection**: User provides comma-separated list (e.g., "testapp1,testapp2")
- **Actions**: User chooses one:
  * none: No action
  * create-schema: Only create/update schemas
  * create-soln-template: Only create/update templates
  * all: Create/update both schemas and templates
- **Validation**: Validates each app directory exists before processing
- **Parallel**: Processes all specified apps concurrently (max 4)

```mermaid
graph TB
    subgraph "Auto Trigger"
        A1[Push to Main] --> B1[Detect Changed Files]
        B1 --> C1[Extract App Names]
        C1 --> D1[Check File Types]
        D1 --> E1{File Type}
        E1 -->|Schema| F1[Create Schema]
        E1 -->|Template/Specs/Metadata| G1[Create Template]
    end
    
    subgraph "Manual Trigger"
        A2[Manual Input] --> B2[App List Input]
        B2 --> C2[Validate Directories]
        C2 --> D2[Action Selection]
        D2 -->|create-schema| E2[Create Schema]
        D2 -->|create-soln-template| F2[Create Template]
        D2 -->|all| G2[Create Both]
    end
```

## Update Process

### 1. App Detection and Validation

- **Push Event**: 
  - Extracts app names from changed file paths (`.pg/<app>/workload-orchestration/`)
  - Creates a list of unique apps to update
  - Changed files determine which actions to take

- **Manual Event**:
  - Validates provided app list against directory structure
  - Action type determines which components to update
  - Processes all files for selected apps regardless of changes

### 2. Azure Login
- Authenticates with Azure using OIDC
- Requires:
  - `AZURE_CLIENT_ID`
  - `AZURE_TENANT_ID`
  - `AZURE_SUBSCRIPTION_ID`

### 3. File Processing
For each app to update:

1. **Get Files**:
   - Locates required files in app's workload-orchestration directory
   - Required patterns:
     * `*-schema.yaml` - Schema definition
     * `*-sol-template.yaml` - Solution template
     * `*-specs.json` - Specifications
     * `metadata.yaml` - Metadata and capabilities

2. **Schema Creation**:
   ```yaml
   az workload-orchestration schema create \
     -g <resource-group> \
     -l <location> \
     --schema-file <path>
   ```

3. **Solution Template Creation**:
   ```yaml
   az workload-orchestration solution-template create \
     -g <resource-group> \
     -l <location> \
     --capabilities <from-metadata> \
     --configuration-template-file <template-path> \
     --specification <specs-path> \
     --enable-external-validation <from-metadata>
   ```

## Error Handling

1. **Schema Version Check**:
   - Verifies schema version exists before creating solution template
   - Fails the operation if required schema version is missing

2. **File Validation**:
   - Validates file existence before processing
   - Logs warnings for missing files
   - Continues processing available files

3. **Capability Validation**:
   - Ensures capabilities are provided either in metadata or as input
   - Fails if no capabilities are found

## Best Practices

1. **File Organization**:
   - Keep all workload orchestration files in `.pg/<app>/workload-orchestration/` directory
   - Use consistent naming patterns
   - Maintain metadata.yaml with current capabilities

2. **Version Management**:
   - Always update schema version before updating solution template version
   - Keep schema and solution template versions in sync

3. **Manual Triggers**:
   - Use for selective updates of specific components
   - Helpful for updating configurations without changes
   - Choose appropriate action type for your needs

## Troubleshooting

1. **Schema Creation Failures**:
   - Verify schema file syntax
   - Check if schema name/version already exists
   - Ensure Azure credentials have proper permissions

2. **Solution Template Issues**:
   - Verify schema version exists
   - Check specification file JSON format
   - Validate capabilities in metadata
   - Check external validation settings

3. **File Detection Issues**:
   - Ensure files use correct naming patterns
   - Verify files are in the workload-orchestration directory
   - Check workflow logs for file detection output

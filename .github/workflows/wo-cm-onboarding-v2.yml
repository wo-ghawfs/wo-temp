name: wo-cm-onboarding-v2

on:
  push:
    branches:
      - main
    paths: 
      - '.pg/**/workload-orchestration/**'
      - '.pg/apps/common/**'
  workflow_run:
      workflows: ["WO-SYNC-VERSIONS"]
      types:
        - completed

  workflow_dispatch:
    inputs:
      update_common:
        type: choice
        description: 'Choose what common resources to update'
        default: none
        options:
        - none
        - schema-only
        - config-only
        - all
        required: true
      action:
        type: choice
        description: Choose app resources to update
        default: none
        options:
        - none
        - create-schema
        - create-soln-template
        - all
        required: true
      apps:
        type: string
        description: 'Comma-separated list of apps to update (e.g., testapp1,testapp2)'
        default: null
      schema_versions:
        type: string
        description: 'Comma-separated list of schema versions to process (e.g., 1.0.0,2.0.0)'
        default: null
      solution_template_versions:
        type: string
        description: 'Comma-separated list of solution template versions to process (e.g., 1.0.0,2.0.0)'
        default: null
      usesiterg:
        type: string
        description: 'RG OVERRIDE - Leave empty to use default from wo-common.yaml'
        default: ""

permissions:
  id-token: write # 
  contents: write # for actions/checkout

jobs:
  # update-context:
  #   runs-on: ubuntu-latest
    
  #   steps:
  #     - name: Azure Login with OIDC
  #       uses: azure/login@v2
  #       with:
  #         client-id: ${{ secrets.AZURE_CLIENT_ID }}
  #         tenant-id: ${{ secrets.AZURE_TENANT_ID }}
  #         subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  #         enable-AzPSSession: true

  #     - uses: actions/checkout@v4

  #     - name: Source composite actions
  #       uses: ./.github/actions/wo-utilities/
  #       with:
  #         utilities: "yq"

  #     - name: Install Workload Orchestration Extension
  #       uses: ./.github/actions/wo-install-wo-extension

  #     - name: Update Context
  #       uses: ./.github/actions/wo-update-context

  detect-apps-resources-to-update:
    # needs: update-context
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ github.event_name == 'workflow_dispatch' && steps.app-list-dispatch.outputs.apps || steps.app-list.outputs.apps }}
      app_changes: ${{ steps.detect-changes.outputs.app_changes }}
    steps:
      - name: Git Info
        id: check-author
        run: |
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"

      - uses: actions/checkout@v4
      - name: Check changed files
        if: github.event_name == 'push' || github.event_name == 'workflow_run'
        id: changed-files
        uses: ./.github/actions/wo-changed-files
        with:
          files: .pg/**/*
          
      - name: Extract apps with changes
        if: github.event_name == 'push' || github.event_name == 'workflow_run'
        id: app-list
        run: |
          # Get all changed files and extract unique app names
          APPS=$(echo "${{ steps.changed-files.outputs.all_changed_files }}" | 
                 grep -o '\.pg/apps/[^/]*/' | 
                 sed 's/\.pg\/apps\///' | 
                 sed 's/\///' | 
                 grep -v '^common$' | 
                 sort -u | 
                 jq -R -s -c 'split("\n")[:-1]')
          echo "apps=$APPS" >> $GITHUB_OUTPUT

      - name: Detect versioned file changes only
        if: github.event_name == 'push' || github.event_name == 'workflow_run'
        id: detect-changes
        run: |
          # Initialize app changes object
          APP_CHANGES="{}"
          
          # Get all changed files
          CHANGED_FILES="${{ steps.changed-files.outputs.all_changed_files }}"
          
          # Process each changed file - ONLY process versioned files
          while IFS= read -r file; do
            app_name=""
            folder_type=""
            version=""
            
            # Check for versioned schema files
            if [[ "$file" =~ ^\.pg/apps/([^/]+)/workload-orchestration/(schemas)/([0-9]+\.[0-9]+\.[0-9]+)/ ]]; then
              app_name="${BASH_REMATCH[1]}"
              folder_type="${BASH_REMATCH[2]}"
              version="${BASH_REMATCH[3]}"
            # Check for versioned solution-template files (.yaml or .json)
            elif [[ "$file" =~ ^\.pg/apps/([^/]+)/workload-orchestration/(solution-templates)/([0-9]+\.[0-9]+\.[0-9]+)/.*\.(yaml|json)$ ]]; then
              app_name="${BASH_REMATCH[1]}"
              folder_type="${BASH_REMATCH[2]}"
              version="${BASH_REMATCH[3]}"
            fi
            
            # Process the file if it matched one of the patterns
            if [[ -n "$app_name" && -n "$folder_type" && -n "$version" ]]; then
              # Skip common app processing here (handled separately)
              if [[ "$app_name" == "common" ]]; then
                continue
              fi
              
              echo "Found versioned change: $app_name/$folder_type/$version - $file"
              
              # Initialize app entry if it doesn't exist
              if [[ $(echo "$APP_CHANGES" | jq -r --arg app "$app_name" '.[$app]') == "null" ]]; then
                APP_CHANGES=$(echo "$APP_CHANGES" | jq --arg app "$app_name" '.[$app] = {"schemas": [], "solution_templates": []}')
              fi
              
              # Update the appropriate versioned array
              if [[ "$folder_type" == "schemas" ]]; then
                APP_CHANGES=$(echo "$APP_CHANGES" | jq --arg app "$app_name" --arg version "$version" '.[$app].schemas |= if . | index($version) then . else . + [$version] end')
              elif [[ "$folder_type" == "solution-templates" ]]; then
                APP_CHANGES=$(echo "$APP_CHANGES" | jq --arg app "$app_name" --arg version "$version" '.[$app].solution_templates |= if . | index($version) then . else . + [$version] end')
              fi
            fi
          done <<< "$(echo "$CHANGED_FILES" | tr ' ' '\n')"
          
          # Write to temporary file and read back (to handle while loop subshell issue)
          echo "$APP_CHANGES" > /tmp/app_changes.json
          APP_CHANGES_FINAL=$(cat /tmp/app_changes.json)
          
          # Compact the JSON to prevent GitHub Actions output formatting issues
          APP_CHANGES_COMPACT=$(echo "$APP_CHANGES_FINAL" | jq -c .)
          
          echo "app_changes=$APP_CHANGES_COMPACT" >> $GITHUB_OUTPUT
          echo "Detected versioned app changes:"
          echo "$APP_CHANGES_FINAL" | jq .

      - name: Extract and validate apps for update
        if: github.event_name == 'workflow_dispatch'
        id: app-list-dispatch
        run: |
          echo "Validating apps from input list for update..."
          APPS_INPUT="${{ github.event.inputs.apps }}"
          
          # Handle empty or whitespace-only input
          if [[ -z "${APPS_INPUT// }" ]]; then
            echo "‚ö†Ô∏è Empty app list provided"
            echo "apps=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          VALID_APPS=()

          # Process each app
          IFS=',' read -ra APP_LIST <<< "$APPS_INPUT"
          for app in "${APP_LIST[@]}"; do
            # Trim whitespace
            app=$(echo "$app" | xargs)
            
            # Validate app directory exists
            if [[ -d ".pg/apps/$app" ]]; then
              VALID_APPS+=("$app")
              echo "‚úÖ Validated app: $app"
            else
              echo "‚ùå Warning: Directory .pg/apps/$app does not exist, skipping"
            fi
          done

          # Convert validated apps to JSON array
          APPS=$(printf '%s\n' "${VALID_APPS[@]}" | jq -R -s -c 'split("\n")[:-1]')
          echo "apps=$APPS" >> $GITHUB_OUTPUT
          echo "‚úÖ Final app list: $APPS"

  update-wo-artifacts:
    needs: [detect-apps-resources-to-update]
    if: needs.detect-apps-resources-to-update.outputs.apps != '[]' && (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'none')
    runs-on: ubuntu-latest
    outputs:
      files_created: ${{ steps.check-created.outputs.files_created }}
    strategy:
      fail-fast: false
      max-parallel: 4  # Limit to 4 concurrent jobs
      matrix:
        app_name: ${{ fromJson(needs.detect-apps-resources-to-update.outputs.apps) }}
    
    steps:
      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true

      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Source composite actions
        uses: ./.github/actions/wo-utilities/
        with:
          utilities: "yq"

      - name: Read Azure config from wo-common.yaml
        run: |
          # Read default values from wo-common.yaml
          DEFAULT_RG=$(yq eval '.common.rg' .pg/sites/common/wo-common.yaml)
          DEFAULT_LOC=$(yq eval '.common.location' .pg/sites/common/wo-common.yaml)
          
          # Check if usesiterg override is provided
          if [[ "${{ github.event.inputs.usesiterg }}" != "" ]]; then
            # Use the override value
            AZURE_RG="${{ github.event.inputs.usesiterg }}"
            echo "Using override resource group: $AZURE_RG"
          else
            # Use the default from config
            AZURE_RG="$DEFAULT_RG"
            echo "Using default resource group from wo-common.yaml: $AZURE_RG"
          fi
          
          # Location always comes from config (no override for location)
          AZURE_LOC="$DEFAULT_LOC"
          
          echo "AZURE_RESOURCE_GROUP=$AZURE_RG" >> $GITHUB_ENV
          echo "AZURE_LOCATION=$AZURE_LOC" >> $GITHUB_ENV
          echo "Final Azure config - RG: $AZURE_RG, Location: $AZURE_LOC"

      - name: Install Workload Orchestration Extension
        uses: ./.github/actions/wo-install-wo-extension

      - name: Check changed files
        if: github.event_name == 'push' || github.event_name == 'workflow_run'
        id: changed-files
        uses: ./.github/actions/wo-changed-files
        with:
          files: .pg/**/*
          
      - name: Detect versioned files and determine actions
        id: detect-actions
        run: |
          BASE_PATH=".pg/apps/${{ matrix.app_name }}/workload-orchestration"
          CREATE_SCHEMA="false"
          CREATE_TEMPLATE="false"
          SCHEMA_FILES=()
          TEMPLATE_FILES=()
          SPEC_FILES=()
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual runs, find specified versioned files for the specified actions
            case "${{ github.event.inputs.action }}" in
              "create-schema"|"all")
                CREATE_SCHEMA="true"
                # Get schema versions from input or use all versions if not specified
                if [[ -n "${{ github.event.inputs.schema_versions }}" ]]; then
                  IFS=',' read -ra SCHEMA_VERSIONS <<< "${{ github.event.inputs.schema_versions }}"
                else
                  # Find all version directories if no specific versions provided
                  if [[ -d "$BASE_PATH/schemas" ]]; then
                    SCHEMA_VERSIONS=()
                    for version_dir in "$BASE_PATH/schemas"/*/ ; do
                      if [[ -d "$version_dir" && "$(basename "$version_dir")" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        SCHEMA_VERSIONS+=("$(basename "$version_dir")")
                      fi
                    done
                  fi
                fi

                # Process each schema version
                for version in "${SCHEMA_VERSIONS[@]}"; do
                  version_dir="$BASE_PATH/schemas/$version"
                  if [[ -d "$version_dir" ]]; then
                    if [[ -f "$version_dir/${{ matrix.app_name }}-schema.yaml" ]]; then
                      SCHEMA_FILES+=("$version_dir/${{ matrix.app_name }}-schema.yaml")
                    elif [[ -f "$version_dir/schema.yaml" ]]; then
                      SCHEMA_FILES+=("$version_dir/schema.yaml")
                    fi
                  else
                    echo "‚ö†Ô∏è Warning: Schema version directory not found: $version_dir"
                  fi
                done
                ;;
            esac

            case "${{ github.event.inputs.action }}" in
              "create-soln-template"|"all")
                CREATE_TEMPLATE="true"
                # Get solution template versions from input or use all versions if not specified
                if [[ -n "${{ github.event.inputs.solution_template_versions }}" ]]; then
                  IFS=',' read -ra TEMPLATE_VERSIONS <<< "${{ github.event.inputs.solution_template_versions }}"
                else
                  # Find all version directories if no specific versions provided
                  if [[ -d "$BASE_PATH/solution-templates" ]]; then
                    TEMPLATE_VERSIONS=()
                    for version_dir in "$BASE_PATH/solution-templates"/*/ ; do
                      if [[ -d "$version_dir" && "$(basename "$version_dir")" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                        TEMPLATE_VERSIONS+=("$(basename "$version_dir")")
                      fi
                    done
                  fi
                fi

                # Process each template version
                for version in "${TEMPLATE_VERSIONS[@]}"; do
                  version_dir="$BASE_PATH/solution-templates/$version"
                  if [[ -d "$version_dir" ]]; then
                    # Find template file
                    TEMPLATE_FILE=""
                    if [[ -f "$version_dir/${{ matrix.app_name }}-sol-template.yaml" ]]; then
                      TEMPLATE_FILE="$version_dir/${{ matrix.app_name }}-sol-template.yaml"
                    elif [[ -f "$version_dir/sol-template.yaml" ]]; then
                      TEMPLATE_FILE="$version_dir/sol-template.yaml"
                    fi
                    
                    # Find corresponding spec file
                    SPEC_FILE=""
                    if [[ -f "$version_dir/${{ matrix.app_name }}-specs.json" ]]; then
                      SPEC_FILE="$version_dir/${{ matrix.app_name }}-specs.json"
                    elif [[ -f "$version_dir/specs.json" ]]; then
                      SPEC_FILE="$version_dir/specs.json"
                    fi
                    
                    # Only add if both files exist
                    if [[ -n "$TEMPLATE_FILE" && -n "$SPEC_FILE" ]]; then
                      TEMPLATE_FILES+=("$TEMPLATE_FILE")
                      SPEC_FILES+=("$SPEC_FILE")
                    elif [[ -n "$TEMPLATE_FILE" ]]; then
                      echo "‚ö†Ô∏è Warning: Template file found but no spec file: $TEMPLATE_FILE"
                    fi
                  else
                    echo "‚ö†Ô∏è Warning: Template version directory not found: $version_dir"
                  fi
                done
                ;;
            esac
          else
            # For push events, check changed files and determine actions based on versioned files only
            APP_CHANGES='${{ needs.detect-apps-resources-to-update.outputs.app_changes }}'
            
            # Check if this app has changes
            APP_DATA=$(echo "$APP_CHANGES" | jq --arg app "${{ matrix.app_name }}" '.[$app] // empty')
            if [[ -n "$APP_DATA" ]]; then
              # Check for versioned schema changes
              SCHEMA_VERSIONS=$(echo "$APP_DATA" | jq -r '.schemas[]?' || true)
              
              if [[ -n "$SCHEMA_VERSIONS" ]]; then
                CREATE_SCHEMA="true"
                
                # Add versioned schema files
                for version in $SCHEMA_VERSIONS; do
                  if [[ -f "$BASE_PATH/schemas/$version/${{ matrix.app_name }}-schema.yaml" ]]; then
                    SCHEMA_FILES+=("$BASE_PATH/schemas/$version/${{ matrix.app_name }}-schema.yaml")
                  elif [[ -f "$BASE_PATH/schemas/$version/schema.yaml" ]]; then
                    SCHEMA_FILES+=("$BASE_PATH/schemas/$version/schema.yaml")
                  fi
                done
              fi
              
              # Check for versioned solution template changes
              TEMPLATE_VERSIONS=$(echo "$APP_DATA" | jq -r '.solution_templates[]?' || true)
              
              if [[ -n "$TEMPLATE_VERSIONS" ]]; then
                CREATE_TEMPLATE="true"
                
                # Add versioned solution template files and their spec files
                for version in $TEMPLATE_VERSIONS; do
                  # Find template file
                  TEMPLATE_FILE=""
                  if [[ -f "$BASE_PATH/solution-templates/$version/${{ matrix.app_name }}-sol-template.yaml" ]]; then
                    TEMPLATE_FILE="$BASE_PATH/solution-templates/$version/${{ matrix.app_name }}-sol-template.yaml"
                  elif [[ -f "$BASE_PATH/solution-templates/$version/sol-template.yaml" ]]; then
                    TEMPLATE_FILE="$BASE_PATH/solution-templates/$version/sol-template.yaml"
                  fi
                  
                  # Find corresponding spec file
                  SPEC_FILE=""
                  if [[ -f "$BASE_PATH/solution-templates/$version/${{ matrix.app_name }}-specs.json" ]]; then
                    SPEC_FILE="$BASE_PATH/solution-templates/$version/${{ matrix.app_name }}-specs.json"
                  elif [[ -f "$BASE_PATH/solution-templates/$version/specs.json" ]]; then
                    SPEC_FILE="$BASE_PATH/solution-templates/$version/specs.json"
                  fi
                  
                  # Only add if both files exist
                  if [[ -n "$TEMPLATE_FILE" && -n "$SPEC_FILE" ]]; then
                    TEMPLATE_FILES+=("$TEMPLATE_FILE")
                    SPEC_FILES+=("$SPEC_FILE")
                  elif [[ -n "$TEMPLATE_FILE" ]]; then
                    echo "‚ö†Ô∏è Warning: Template file found but no spec file: $TEMPLATE_FILE"
                  fi
                done
              fi
            fi
          fi
          
          # Convert arrays to JSON
          SCHEMA_FILES_JSON=$(printf '%s\n' "${SCHEMA_FILES[@]}" | jq -R -s -c 'split("\n")[:-1]')
          TEMPLATE_FILES_JSON=$(printf '%s\n' "${TEMPLATE_FILES[@]}" | jq -R -s -c 'split("\n")[:-1]')
          SPEC_FILES_JSON=$(printf '%s\n' "${SPEC_FILES[@]}" | jq -R -s -c 'split("\n")[:-1]')
          
          # Set outputs
          echo "create_schema=$CREATE_SCHEMA" >> $GITHUB_OUTPUT
          echo "create_template=$CREATE_TEMPLATE" >> $GITHUB_OUTPUT
          echo "schema_files=$SCHEMA_FILES_JSON" >> $GITHUB_OUTPUT
          echo "template_files=$TEMPLATE_FILES_JSON" >> $GITHUB_OUTPUT
          echo "spec_files=$SPEC_FILES_JSON" >> $GITHUB_OUTPUT
          
          echo "Actions for ${{ matrix.app_name }}: schema=$CREATE_SCHEMA, template=$CREATE_TEMPLATE"
          echo "Schema files: $SCHEMA_FILES_JSON"
          echo "Template files: $TEMPLATE_FILES_JSON"
          echo "Spec files: $SPEC_FILES_JSON"

      - name: Create App Schemas (Versioned Only)
        id: create-schemas
        if: steps.detect-actions.outputs.create_schema == 'true'
        uses: ./.github/actions/wo-create-schema
        with:
          app-name: ${{ matrix.app_name }}
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          location: ${{ env.AZURE_LOCATION }}
          schema-files: ${{ steps.detect-actions.outputs.schema_files }}

      - name: Store Schema Results
        id: store-schema-results
        if: steps.detect-actions.outputs.create_schema == 'true'
        run: |
          # Store schema validation results as artifacts for aggregation
          mkdir -p schema-results
          
          # Create a result file for this matrix job
          RESULT_FILE="schema-results/${{ matrix.app_name }}-results.json"
          
          cat > "$RESULT_FILE" << EOF
          {
            "app_name": "${{ matrix.app_name }}",
            "schemas_skipped": "${{ steps.create-schemas.outputs.schemas-skipped || '0' }}",
            "schemas_failed": "${{ steps.create-schemas.outputs.schemas-failed || '0' }}",
            "skipped_schemas_details": ${{ steps.create-schemas.outputs.skipped-schemas-details || '[]' }},
            "failed_schemas_details": ${{ steps.create-schemas.outputs.failed-schemas-details || '[]' }}
          }
          EOF
          
          echo "Schema results for ${{ matrix.app_name }}:"
          cat "$RESULT_FILE"

      - name: Upload Schema Results
        if: steps.detect-actions.outputs.create_schema == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: schema-results-${{ matrix.app_name }}
          path: schema-results/
          retention-days: 1

      - name: Create App Solution Templates (Versioned Only)
        id: create-templates
        if: steps.detect-actions.outputs.create_template == 'true'
        uses: ./.github/actions/wo-create-solution-template
        with:
          app-name: ${{ matrix.app_name }}
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          location: ${{ env.AZURE_LOCATION }}
          template-files: ${{ steps.detect-actions.outputs.template_files }}
          specification-files: ${{ steps.detect-actions.outputs.spec_files }}
          metadata-file: .pg/apps/${{ matrix.app_name }}/workload-orchestration/metadata.yaml

      - name: Store Template Results
        id: store-template-results
        if: steps.detect-actions.outputs.create_template == 'true'
        run: |
          # Store solution template validation results as artifacts for aggregation
          mkdir -p template-results
          
          # Create a result file for this matrix job
          RESULT_FILE="template-results/${{ matrix.app_name }}-results.json"
          
          cat > "$RESULT_FILE" << EOF
          {
            "app_name": "${{ matrix.app_name }}",
            "templates_skipped": "${{ steps.create-templates.outputs.templates-skipped || '0' }}",
            "templates_failed": "${{ steps.create-templates.outputs.templates-failed || '0' }}",
            "skipped_templates_details": ${{ steps.create-templates.outputs.skipped-templates-details || '[]' }},
            "failed_templates_details": ${{ steps.create-templates.outputs.failed-templates-details || '[]' }}
          }
          EOF
          
          echo "Template results for ${{ matrix.app_name }}:"
          cat "$RESULT_FILE"

      - name: Upload Template Results
        if: steps.detect-actions.outputs.create_template == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: template-results-${{ matrix.app_name }}
          path: template-results/
          retention-days: 1

      - name: Check if files were created
        id: check-created
        run: |
          # Check if any files were created (either schema or template)
          if [[ "${{ steps.create-templates.outputs.files_created }}" == "true" ]] || [[ "${{ steps.detect-actions.outputs.create_schema }}" == "true" ]]; then
            echo "files_created=true" >> $GITHUB_OUTPUT
          else
            echo "files_created=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload generated files
        if: steps.check-created.outputs.files_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: generated-artifacts-${{ matrix.app_name }}
          path: .pg/apps/${{ matrix.app_name }}/solutions/
          retention-days: 1
          if-no-files-found: warn

  update_common_artifacts:
    # needs: update-context
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.update_common != 'none' }}
    runs-on: ubuntu-latest
    outputs:
      files_created: ${{ steps.check-created.outputs.files_created }}
    steps:
      - name: Azure Login with OIDC
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true

      - uses: actions/checkout@v4

      - name: Source composite actions
        uses: ./.github/actions/wo-utilities/
        with:
          utilities: "yq"

      - name: Read Azure config from wo-common.yaml
        run: |
          # Read default values from wo-common.yaml
          DEFAULT_RG=$(yq eval '.common.rg' .pg/sites/common/wo-common.yaml)
          DEFAULT_LOC=$(yq eval '.common.location' .pg/sites/common/wo-common.yaml)
          
          # Check if usesiterg override is provided
          if [[ "${{ github.event.inputs.usesiterg }}" != "" ]]; then
            # Use the override value
            AZURE_RG="${{ github.event.inputs.usesiterg }}"
            echo "Using override resource group: $AZURE_RG"
          else
            # Use the default from config
            AZURE_RG="$DEFAULT_RG"
            echo "Using default resource group from wo-common.yaml: $AZURE_RG"
          fi
          
          # Location always comes from config (no override for location)
          AZURE_LOC="$DEFAULT_LOC"
          
          echo "AZURE_RESOURCE_GROUP=$AZURE_RG" >> $GITHUB_ENV
          echo "AZURE_LOCATION=$AZURE_LOC" >> $GITHUB_ENV
          echo "Final Azure config - RG: $AZURE_RG, Location: $AZURE_LOC"

      - name: Install Workload Orchestration Extension
        uses: ./.github/actions/wo-install-wo-extension

      - name: Get files
        id: get-files
        run: |
          # Verify schema file exists
          SCHEMA_PATH=".pg/apps/common/common-schema.yaml"
          if [[ -f "$SCHEMA_PATH" ]]; then
            echo "schema_file=$SCHEMA_PATH" >> $GITHUB_OUTPUT
          else
            echo "::warning::Common schema file not found at $SCHEMA_PATH"
          fi
          
          # Verify config template file exists
          CONFIG_PATH=".pg/apps/common/common-config-template.yaml"
          if [[ -f "$CONFIG_PATH" ]]; then
            echo "config_file=$CONFIG_PATH" >> $GITHUB_OUTPUT
          else
            echo "::warning::Common config template file not found at $CONFIG_PATH"
          fi
        
      - name: Check changed files
        if: github.event_name == 'push' || github.event_name == 'workflow_run'
        id: changed-files
        uses: ./.github/actions/wo-changed-files
        with:
          files: .pg/apps/common/*

      - name: Set update flags
        id: update-flags
        run: |
          # Initialize flags
          UPDATE_COMMON_SCHEMA="false"
          UPDATE_COMMON_CONFIG="false"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual runs, check update_common input
            case "${{ github.event.inputs.update_common }}" in
              "schema-only"|"all")
                UPDATE_COMMON_SCHEMA="true"
                ;;
            esac
            case "${{ github.event.inputs.update_common }}" in
              "config-only"|"all")
                UPDATE_COMMON_CONFIG="true"
                ;;
            esac
          else
            # For push events, check changed files
            if [[ $(echo "${{ steps.changed-files.outputs.all_changed_files }}" | grep -c ".pg/apps/common/common-schema.yaml") -gt 0 ]]; then
              UPDATE_COMMON_SCHEMA="true"
            fi
            if [[ $(echo "${{ steps.changed-files.outputs.all_changed_files }}" | grep -c ".pg/apps/common/common-config-template.yaml") -gt 0 ]]; then
              UPDATE_COMMON_CONFIG="true"
            fi
          fi

          # Set outputs
          echo "update_schema=$UPDATE_COMMON_SCHEMA" >> $GITHUB_OUTPUT
          echo "update_config=$UPDATE_COMMON_CONFIG" >> $GITHUB_OUTPUT

          # Echo final status using local variables
          echo "Set flags: schema=$UPDATE_COMMON_SCHEMA, template=$UPDATE_COMMON_CONFIG"

      - name: Create Common Schema
        if: steps.update-flags.outputs.update_schema == 'true'
        uses: ./.github/actions/wo-create-schema
        with:
          app-name: common
          azure-credentials: ${{ secrets.AZURE_CREDENTIALS }}
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          location: ${{ env.AZURE_LOCATION }}
          schema-file: ${{ steps.get-files.outputs.schema_file }}

      - name: Create Common Config Template
        id: create-config
        if: steps.update-flags.outputs.update_config == 'true'
        uses: ./.github/actions/wo-create-config-template
        with:
          azure-credentials: ${{ secrets.AZURE_CREDENTIALS }}
          resource-group: ${{ env.AZURE_RESOURCE_GROUP }}
          config-template-file: ${{ steps.get-files.outputs.config_file }}
          description: "Common configuration template for shared settings"
          location: ${{ env.AZURE_LOCATION }}

      - name: Check if files were created
        id: check-created
        run: |
          # Check if any files were created (either schema or config)
          if [[ "${{ steps.create-config.outputs.files_created }}" == "true" ]] || [[ "${{ steps.update-flags.outputs.update_schema }}" == "true" ]]; then
            echo "files_created=true" >> $GITHUB_OUTPUT
          else
            echo "files_created=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload generated files
        if: steps.check-created.outputs.files_created == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: generated-artifacts-common
          path: .pg/apps/common/solutions/
          retention-days: 1
          if-no-files-found: warn

  commit-generated-files:
    needs: [update-wo-artifacts, update_common_artifacts]
    if: always() && (needs.update-wo-artifacts.outputs.files_created == 'true' || needs.update_common_artifacts.outputs.files_created == 'true')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: generated-artifacts-*
          path: downloaded-artifacts

      - name: Process and copy artifacts to correct locations
        run: |
          echo "Processing downloaded artifacts..."
          
          # Create solutions directories if they don't exist
          mkdir -p .pg/apps/common/solutions
          
          # Process each artifact
          for artifact_dir in downloaded-artifacts/generated-artifacts-*; do
            if [ -d "$artifact_dir" ]; then
              artifact_name=$(basename "$artifact_dir")
              echo "Processing $artifact_name"
              
              if [[ "$artifact_name" == "generated-artifacts-common" ]]; then
                # Copy common solutions
                if [ -d "$artifact_dir" ]; then
                  cp -r "$artifact_dir"/* .pg/apps/common/solutions/ 2>/dev/null || echo "No files to copy for common"
                fi
              else
                # Extract app name from artifact name
                app_name=${artifact_name#generated-artifacts-}
                echo "Processing app: $app_name"
                
                # Create app solutions directory
                mkdir -p ".pg/apps/$app_name/solutions"
                
                # Copy app solutions
                if [ -d "$artifact_dir" ]; then
                  cp -r "$artifact_dir"/* ".pg/apps/$app_name/solutions/" 2>/dev/null || echo "No files to copy for $app_name"
                fi
              fi
            fi
          done
          
          # List what was copied for debugging
          echo "Files copied:"
          find .pg -name "*.json" -o -name "*.yaml" | head -20

      - name: Commit all generated files
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Generated workload orchestration artifacts (v2 - versioned only)"
          file_pattern: ".pg/**"

  report-schema-validation-errors:
    needs: [update-wo-artifacts, commit-generated-files]
    if: always() && needs.update-wo-artifacts.result != 'skipped'
    runs-on: ubuntu-latest
    steps:
      - name: Download schema results
        uses: actions/download-artifact@v4
        with:
          pattern: schema-results-*
          path: schema-results
          merge-multiple: true
        continue-on-error: true

      - name: Process and report schema validation results
        run: |
          TOTAL_SKIPPED=0
          TOTAL_FAILED=0
          ALL_SKIPPED_DETAILS="[]"
          ALL_FAILED_DETAILS="[]"
          
          echo "Processing schema results..."
          
          # Check if schema-results directory exists and has files
          if [[ -d "schema-results" && $(ls -A schema-results/ 2>/dev/null) ]]; then
            # Process each result file
            for result_file in schema-results/*-results.json; do
              if [[ -f "$result_file" ]]; then
                echo "Processing: $result_file"
                
                SKIPPED=$(jq -r '.schemas_skipped // "0"' "$result_file")
                FAILED=$(jq -r '.schemas_failed // "0"' "$result_file")
                SKIPPED_DETAILS=$(jq -c '.skipped_schemas_details // []' "$result_file")
                FAILED_DETAILS=$(jq -c '.failed_schemas_details // []' "$result_file")
                
                echo "  Skipped: $SKIPPED, Failed: $FAILED"
                
                # Add to totals
                TOTAL_SKIPPED=$((TOTAL_SKIPPED + SKIPPED))
                TOTAL_FAILED=$((TOTAL_FAILED + FAILED))
                
                # Merge details
                if [[ "$SKIPPED_DETAILS" != "[]" ]]; then
                  ALL_SKIPPED_DETAILS=$(echo "$ALL_SKIPPED_DETAILS" | jq --argjson new "$SKIPPED_DETAILS" '. + $new')
                fi
                
                if [[ "$FAILED_DETAILS" != "[]" ]]; then
                  ALL_FAILED_DETAILS=$(echo "$ALL_FAILED_DETAILS" | jq --argjson new "$FAILED_DETAILS" '. + $new')
                fi
              fi
            done
          else
            echo "No schema results found - no schema validation was performed"
            exit 0
          fi
          
          echo ""
          echo "üìä Aggregated Results:"
          echo "   Total schemas skipped: $TOTAL_SKIPPED"
          echo "   Total schemas failed: $TOTAL_FAILED"
          
          # Only report and fail if there are actually issues
          if [[ $TOTAL_SKIPPED -gt 0 || $TOTAL_FAILED -gt 0 ]]; then
            echo ""
            echo "üö® Schema Validation Issues Found:"
            echo ""
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚è≠Ô∏è  Skipped Schemas (Version Conflicts): $TOTAL_SKIPPED"
              echo "The following schema versions were skipped because they already exist:"
              echo "$ALL_SKIPPED_DETAILS" | jq -r '.[] | "   - \(.["schema-name"]) v\(.version) (\(.file))"'
              echo ""
            fi
            
            if [[ "$TOTAL_FAILED" -gt 0 ]]; then
              echo "‚ùå Failed Schema Creations: $TOTAL_FAILED"
              echo "The following schema creations failed:"
              echo "$ALL_FAILED_DETAILS" | jq -r '.[] | "   - \(.["schema-name"]) v\(.version): \(.error) (\(.file))"'
              echo ""
              echo "üîç Detailed Error Information:"
              echo "$ALL_FAILED_DETAILS" | jq -r '.[] | "   File: \(.file)\n   Schema: \(.["schema-name"]) v\(.version)\n   Error: \(.error)\n   Details: \(.["error-details"])\n"'
            fi
            
            echo "üìù Summary:"
            echo "   Total schemas skipped: $TOTAL_SKIPPED"
            echo "   Total schemas failed: $TOTAL_FAILED"
            echo ""
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚ö†Ô∏è  Skipped schemas indicate version conflicts. Please create new versions for any changes to existing versioned files."
            fi
            
            if [[ "$TOTAL_FAILED" -gt 0 ]]; then
              echo "‚ùå Failed schema creations require attention. Please review the errors above and fix the underlying issues."
              exit 1
            fi
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚ö†Ô∏è  The workflow completed successfully but some schemas were skipped due to version conflicts."
              exit 1
            fi
          else
            echo "‚úÖ All schema validations passed successfully"
          fi

  report-template-validation-errors:
    needs: [update-wo-artifacts, commit-generated-files]
    if: always() && needs.update-wo-artifacts.result != 'skipped'
    runs-on: ubuntu-latest
    steps:
      - name: Download template results
        uses: actions/download-artifact@v4
        with:
          pattern: template-results-*
          path: template-results
          merge-multiple: true
        continue-on-error: true

      - name: Process and report template validation results
        run: |
          TOTAL_SKIPPED=0
          TOTAL_FAILED=0
          ALL_SKIPPED_DETAILS="[]"
          ALL_FAILED_DETAILS="[]"
          
          echo "Processing template results..."
          
          # Check if template-results directory exists and has files
          if [[ -d "template-results" && $(ls -A template-results/ 2>/dev/null) ]]; then
            # Process each result file
            for result_file in template-results/*-results.json; do
              if [[ -f "$result_file" ]]; then
                echo "Processing: $result_file"
                
                SKIPPED=$(jq -r '.templates_skipped // "0"' "$result_file")
                FAILED=$(jq -r '.templates_failed // "0"' "$result_file")
                SKIPPED_DETAILS=$(jq -c '.skipped_templates_details // []' "$result_file")
                FAILED_DETAILS=$(jq -c '.failed_templates_details // []' "$result_file")
                
                echo "  Skipped: $SKIPPED, Failed: $FAILED"
                
                # Add to totals
                TOTAL_SKIPPED=$((TOTAL_SKIPPED + SKIPPED))
                TOTAL_FAILED=$((TOTAL_FAILED + FAILED))
                
                # Merge details
                if [[ "$SKIPPED_DETAILS" != "[]" ]]; then
                  ALL_SKIPPED_DETAILS=$(echo "$ALL_SKIPPED_DETAILS" | jq --argjson new "$SKIPPED_DETAILS" '. + $new')
                fi
                
                if [[ "$FAILED_DETAILS" != "[]" ]]; then
                  ALL_FAILED_DETAILS=$(echo "$ALL_FAILED_DETAILS" | jq --argjson new "$FAILED_DETAILS" '. + $new')
                fi
              fi
            done
          else
            echo "No template results found - no template validation was performed"
            exit 0
          fi
          
          echo ""
          echo "üìä Aggregated Results:"
          echo "   Total templates skipped: $TOTAL_SKIPPED"
          echo "   Total templates failed: $TOTAL_FAILED"
          
          # Only report and fail if there are actually issues
          if [[ $TOTAL_SKIPPED -gt 0 || $TOTAL_FAILED -gt 0 ]]; then
            echo ""
            echo "üö® Template Validation Issues Found:"
            echo ""
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚è≠Ô∏è  Skipped Templates (Version Conflicts): $TOTAL_SKIPPED"
              echo "The following template versions were skipped because they already exist:"
              echo "$ALL_SKIPPED_DETAILS" | jq -r '.[] | "   - \(.["template-name"]) v\(.version) (\(.file))"'
              echo ""
            fi
            
            if [[ "$TOTAL_FAILED" -gt 0 ]]; then
              echo "‚ùå Failed Template Creations: $TOTAL_FAILED"
              echo "The following template creations failed:"
              echo "$ALL_FAILED_DETAILS" | jq -r '.[] | "   - \(.["template-name"]) v\(.version): \(.error) (\(.file))"'
              echo ""
              echo "üîç Detailed Error Information:"
              echo "$ALL_FAILED_DETAILS" | jq -r '.[] | "   File: \(.file)\n   Template: \(.["template-name"]) v\(.version)\n   Error: \(.error)\n   Details: \(.["error-details"])\n"'
            fi
            
            echo "üìù Summary:"
            echo "   Total templates skipped: $TOTAL_SKIPPED"
            echo "   Total templates failed: $TOTAL_FAILED"
            echo ""
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚ö†Ô∏è  Skipped templates indicate version conflicts. Please create new versions for any changes to existing versioned files."
            fi
            
            if [[ "$TOTAL_FAILED" -gt 0 ]]; then
              echo "‚ùå Failed template creations require attention. Please review the errors above and fix the underlying issues."
              exit 1
            fi
            
            if [[ "$TOTAL_SKIPPED" -gt 0 ]]; then
              echo "‚ö†Ô∏è  The workflow completed successfully but some templates were skipped due to version conflicts."
              exit 1
            fi
          else
            echo "‚úÖ All template validations passed successfully"
          fi

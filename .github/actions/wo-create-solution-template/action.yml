name: Create Workload Orchestration Solution Template
description: Creates an Azure Workload Orchestration Solution Template using provided parameters

outputs:
  files_created:
    description: 'Whether solution template metadata files were created'
    value: ${{ steps.process-templates.outputs.files_created }}
  templates-skipped:
    description: 'Number of templates that were skipped (already existed)'
    value: ${{ steps.process-templates.outputs.templates_skipped }}
  templates-failed:
    description: 'Number of templates that failed to create'
    value: ${{ steps.process-templates.outputs.templates_failed }}
  skipped-templates-details:
    description: 'JSON array with details of skipped templates'
    value: ${{ steps.process-templates.outputs.skipped_templates_details }}
  failed-templates-details:
    description: 'JSON array with details of failed templates'
    value: ${{ steps.process-templates.outputs.failed_templates_details }}

inputs:
  app-name:
    description: 'Name of the application (folder name)'
    required: true
  azure-credentials:
    description: 'Azure credentials for authentication'
    required: false
  resource-group:
    description: 'Azure Resource Group name'
    required: true
  location:
    description: 'Azure region location'
    required: true
  # Single file inputs (for backward compatibility)
  solution-template-name:
    description: 'Name of the solution template (if not provided, read from template file)'
    required: false
  solution-template-version:
    description: 'Version of the solution template (if not provided, read from template file)'
    required: false
  capabilities:
    description: 'Capabilities for the solution template as JSON array (e.g. ["cap1","cap2"]). If not provided, read from metadata'
    required: false
    type: string
    default: '[]'
  template-file:
    description: 'Path to the solution template file (single file mode)'
    required: false
  specification-file:
    description: 'Path to the specification file (single file mode)'
    required: false
  metadata-file:
    description: 'Path to the metadata file'
    required: true
  description:
    description: 'Description of the solution template'
    required: false
  enable-external-validation:
    description: 'Enable external validation for the solution template'
    required: false
    type: string
  # Batch processing inputs
  template-files:
    description: 'JSON array of template file paths for batch processing'
    required: false
  specification-files:
    description: 'JSON array of specification file paths (must match template-files order)'
    required: false

runs:
  using: composite
  steps:
    - name: Determine Processing Mode
      shell: bash
      run: |
        if [[ -n "${{ inputs.template-files }}" ]]; then
          echo "PROCESSING_MODE=batch" >> $GITHUB_ENV
          echo "Using batch processing mode"
        elif [[ -n "${{ inputs.template-file }}" ]]; then
          echo "PROCESSING_MODE=single" >> $GITHUB_ENV
          echo "Using single file mode (backward compatibility)"
        else
          echo "Error: Either template-files or template-file must be provided"
          exit 1
        fi

    - name: Process Solution Templates
      id: process-templates
      shell: bash
      run: |
        # Initialize counters and arrays for tracking results
        TEMPLATES_CREATED=0
        TEMPLATES_SKIPPED=0
        TEMPLATES_FAILED=0
        SKIPPED_TEMPLATES_DETAILS="[]"
        FAILED_TEMPLATES_DETAILS="[]"
        FILES_CREATED=false
        
        # Read metadata once (common to all templates)
        TEMPLATE_DESCRIPTION=$(yq eval '.description' "${{ inputs.metadata-file }}")
        TEMPLATE_CAPABILITIES="[$(yq eval '.capabilities[]' "${{ inputs.metadata-file }}" | tr '\n' ',' | sed 's/,$//')]"
        TEMPLATE_ENABLE_VALIDATION=$(yq eval '.enable-external-validation' "${{ inputs.metadata-file }}")
        
        # Override with input values if provided
        if [[ -n "${{ inputs.description }}" ]]; then
          TEMPLATE_DESCRIPTION="${{ inputs.description }}"
        fi
        if [[ "${{ inputs.capabilities }}" != "[]" ]]; then
          TEMPLATE_CAPABILITIES="${{ inputs.capabilities }}"
        fi
        if [[ -n "${{ inputs.enable-external-validation }}" ]]; then
          TEMPLATE_ENABLE_VALIDATION="${{ inputs.enable-external-validation }}"
        fi
        
        echo "Common template settings:"
        echo "  Description: $TEMPLATE_DESCRIPTION"
        echo "  Capabilities: $TEMPLATE_CAPABILITIES"
        echo "  Enable Validation: $TEMPLATE_ENABLE_VALIDATION"
        
        # Process templates based on mode
        if [[ "$PROCESSING_MODE" == "batch" ]]; then
          echo "Processing templates in batch mode..."
          TEMPLATE_FILES='${{ inputs.template-files }}'
          SPEC_FILES='${{ inputs.specification-files }}'
          
          # Get array lengths
          TEMPLATE_COUNT=$(echo "$TEMPLATE_FILES" | jq 'length')
          SPEC_COUNT=$(echo "$SPEC_FILES" | jq 'length')
          
          if [[ $TEMPLATE_COUNT -ne $SPEC_COUNT ]]; then
            echo "Error: template-files and specification-files arrays must have the same length"
            echo "Template files: $TEMPLATE_COUNT, Specification files: $SPEC_COUNT"
            exit 1
          fi
          
          echo "Processing $TEMPLATE_COUNT template files..."
          
          for i in $(seq 0 $((TEMPLATE_COUNT - 1))); do
            TEMPLATE_FILE=$(echo "$TEMPLATE_FILES" | jq -r ".[$i]")
            SPEC_FILE=$(echo "$SPEC_FILES" | jq -r ".[$i]")
            
            echo "Processing template $((i + 1))/$TEMPLATE_COUNT: $TEMPLATE_FILE"
            
            # Process single template
            RESULT=$(bash -c "
              source_template_processing() {
                local template_file=\$1
                local spec_file=\$2
                
                # Read template metadata
                TEMPLATE_NAME=\$(yq eval '.metadata.name' \"\$template_file\")
                TEMPLATE_VERSION=\$(yq eval '.metadata.version' \"\$template_file\")
                SCHEMA_NAME=\$(yq eval '.schema.name' \"\$template_file\")
                SCHEMA_VERSION=\$(yq eval '.schema.version' \"\$template_file\")
                
                echo \"Processing: \$TEMPLATE_NAME v\$TEMPLATE_VERSION\"
                
                # Check if schema version exists
                if ! az workload-orchestration schema version show -g '${{ inputs.resource-group }}' --schema-name \"\$SCHEMA_NAME\" -v \"\$SCHEMA_VERSION\" >/dev/null 2>&1; then
                  echo \"ERROR: Schema \$SCHEMA_NAME v\$SCHEMA_VERSION does not exist\"
                  echo \"FAILED|\$template_file|\$TEMPLATE_NAME|\$TEMPLATE_VERSION|Schema \$SCHEMA_NAME v\$SCHEMA_VERSION does not exist|Please ensure the schema and version exist before creating the solution template\"
                  return 1
                fi
                
                # Check if solution template version already exists
                if az workload-orchestration solution-template version show -g '${{ inputs.resource-group }}' --solution-template-name \"\$TEMPLATE_NAME\" -v \"\$TEMPLATE_VERSION\" >/dev/null 2>&1; then
                  echo \"SKIPPED|\$template_file|\$TEMPLATE_NAME|\$TEMPLATE_VERSION|Solution template version already exists\"
                  return 0
                fi
                
                # Create solution template
                RESPONSE=\$(az workload-orchestration solution-template create \
                  -g '${{ inputs.resource-group }}' \
                  -l '${{ inputs.location }}' \
                  --capabilities '$TEMPLATE_CAPABILITIES' \
                  --configuration-template-file \"\$template_file\" \
                  --specification \"\$spec_file\" \
                  --description '$TEMPLATE_DESCRIPTION' \
                  --enable-external-validation '$TEMPLATE_ENABLE_VALIDATION' \
                  --output json 2>&1)
                
                if [[ \$? -ne 0 ]]; then
                  echo \"FAILED|\$template_file|\$TEMPLATE_NAME|\$TEMPLATE_VERSION|Azure CLI creation failed|\$RESPONSE\"
                  return 1
                fi
                
                # Extract resource IDs
                SOLUTION_TEMPLATE_ID=\$(echo \"\$RESPONSE\" | jq -r '.properties.solutionTemplateId // empty')
                SOLUTION_TEMPLATE_VERSION_ID=\$(echo \"\$RESPONSE\" | jq -r '.properties.solutionTemplateVersionId // empty')
                
                echo \"CREATED|\$template_file|\$TEMPLATE_NAME|\$TEMPLATE_VERSION|\$SOLUTION_TEMPLATE_ID|\$SOLUTION_TEMPLATE_VERSION_ID\"
              }
              
              source_template_processing '$TEMPLATE_FILE' '$SPEC_FILE'
            ")
            
            # Parse result
            IFS='|' read -ra RESULT_PARTS <<< "$RESULT"
            STATUS="${RESULT_PARTS[0]}"
            
            case "$STATUS" in
              "CREATED")
                TEMPLATES_CREATED=$((TEMPLATES_CREATED + 1))
                FILES_CREATED=true
                TEMPLATE_FILE_PATH="${RESULT_PARTS[1]}"
                TEMPLATE_NAME="${RESULT_PARTS[2]}"
                TEMPLATE_VERSION="${RESULT_PARTS[3]}"
                SOLUTION_TEMPLATE_ID="${RESULT_PARTS[4]}"
                SOLUTION_TEMPLATE_VERSION_ID="${RESULT_PARTS[5]}"
                
                # Create metadata file
                FOLDER_PATH=".pg/apps/${{ inputs.app-name }}/solutions"
                mkdir -p "$FOLDER_PATH"
                YAML_FILE="$FOLDER_PATH/$TEMPLATE_NAME.yaml"
                
                if [[ -f "$YAML_FILE" ]]; then
                  # Check if version already exists in file
                  EXISTING_VERSION=$(yq eval ".versions[] | select(.version == \"$TEMPLATE_VERSION\") | .version" "$YAML_FILE" 2>/dev/null || echo "")
                  if [[ -z "$EXISTING_VERSION" ]]; then
                    yq eval ".versions += [{\"version\": \"$TEMPLATE_VERSION\", \"solutionTemplateVersionId\": \"$SOLUTION_TEMPLATE_VERSION_ID\", \"revisions\": []}]" -i "$YAML_FILE"
                  fi
                else
                  # Create new file
                  yq eval -n '.solutionTemplateName = "'"$TEMPLATE_NAME"'"' > "$YAML_FILE"
                  yq eval '.solutionTemplateId = "'"$SOLUTION_TEMPLATE_ID"'"' -i "$YAML_FILE"
                  yq eval '.versions = []' -i "$YAML_FILE"
                  yq eval '.versions += [{"version": "'"$TEMPLATE_VERSION"'", "solutionTemplateVersionId": "'"$SOLUTION_TEMPLATE_VERSION_ID"'", "revisions": []}]' -i "$YAML_FILE"
                fi
                echo "âœ… Created: $TEMPLATE_NAME v$TEMPLATE_VERSION"
                ;;
              "SKIPPED")
                TEMPLATES_SKIPPED=$((TEMPLATES_SKIPPED + 1))
                TEMPLATE_FILE_PATH="${RESULT_PARTS[1]}"
                TEMPLATE_NAME="${RESULT_PARTS[2]}"
                TEMPLATE_VERSION="${RESULT_PARTS[3]}"
                SKIP_REASON="${RESULT_PARTS[4]}"
                
                SKIPPED_DETAILS=$(echo "$SKIPPED_TEMPLATES_DETAILS" | jq --arg file "$TEMPLATE_FILE_PATH" --arg name "$TEMPLATE_NAME" --arg version "$TEMPLATE_VERSION" --arg reason "$SKIP_REASON" '. + [{"file": $file, "template-name": $name, "version": $version, "reason": $reason}]')
                SKIPPED_TEMPLATES_DETAILS="$SKIPPED_DETAILS"
                echo "â­ï¸ Skipped: $TEMPLATE_NAME v$TEMPLATE_VERSION ($SKIP_REASON)"
                ;;
              "FAILED")
                TEMPLATES_FAILED=$((TEMPLATES_FAILED + 1))
                TEMPLATE_FILE_PATH="${RESULT_PARTS[1]}"
                TEMPLATE_NAME="${RESULT_PARTS[2]}"
                TEMPLATE_VERSION="${RESULT_PARTS[3]}"
                ERROR="${RESULT_PARTS[4]}"
                ERROR_DETAILS="${RESULT_PARTS[5]}"
                
                FAILED_DETAILS=$(echo "$FAILED_TEMPLATES_DETAILS" | jq --arg file "$TEMPLATE_FILE_PATH" --arg name "$TEMPLATE_NAME" --arg version "$TEMPLATE_VERSION" --arg error "$ERROR" --arg details "$ERROR_DETAILS" '. + [{"file": $file, "template-name": $name, "version": $version, "error": $error, "error-details": $details}]')
                FAILED_TEMPLATES_DETAILS="$FAILED_DETAILS"
                echo "âŒ Failed: $TEMPLATE_NAME v$TEMPLATE_VERSION ($ERROR)"
                ;;
            esac
          done
        else
          echo "Processing single template (backward compatibility mode)..."
          # Single file processing (original logic for backward compatibility)
          TEMPLATE_NAME=$(yq eval '.metadata.name' "${{ inputs.template-file }}")
          TEMPLATE_VERSION=$(yq eval '.metadata.version' "${{ inputs.template-file }}")
          SCHEMA_NAME=$(yq eval '.schema.name' "${{ inputs.template-file }}")
          SCHEMA_VERSION=$(yq eval '.schema.version' "${{ inputs.template-file }}")
          
          # Override with provided values if given
          if [[ -n "${{ inputs.solution-template-name }}" ]]; then
            TEMPLATE_NAME="${{ inputs.solution-template-name }}"
          fi
          if [[ -n "${{ inputs.solution-template-version }}" ]]; then
            TEMPLATE_VERSION="${{ inputs.solution-template-version }}"
          fi
          
          echo "Processing: $TEMPLATE_NAME v$TEMPLATE_VERSION"
          
          # Check schema exists
          if ! az workload-orchestration schema version show -g ${{ inputs.resource-group }} --schema-name "$SCHEMA_NAME" -v "$SCHEMA_VERSION" >/dev/null 2>&1; then
            echo "Error: Schema $SCHEMA_NAME v$SCHEMA_VERSION does not exist"
            TEMPLATES_FAILED=1
            FAILED_TEMPLATES_DETAILS=$(echo '[]' | jq --arg file "${{ inputs.template-file }}" --arg name "$TEMPLATE_NAME" --arg version "$TEMPLATE_VERSION" --arg error "Schema does not exist" --arg details "Schema $SCHEMA_NAME v$SCHEMA_VERSION does not exist" '. + [{"file": $file, "template-name": $name, "version": $version, "error": $error, "error-details": $details}]')
          elif az workload-orchestration solution-template version show -g ${{ inputs.resource-group }} --solution-template-name "$TEMPLATE_NAME" -v "$TEMPLATE_VERSION" >/dev/null 2>&1; then
            echo "Solution template version already exists. Skipping."
            TEMPLATES_SKIPPED=1
            SKIPPED_TEMPLATES_DETAILS=$(echo '[]' | jq --arg file "${{ inputs.template-file }}" --arg name "$TEMPLATE_NAME" --arg version "$TEMPLATE_VERSION" --arg reason "Solution template version already exists" '. + [{"file": $file, "template-name": $name, "version": $version, "reason": $reason}]')
          else
            # Create solution template
            RESPONSE=$(az workload-orchestration solution-template create \
              -g ${{ inputs.resource-group }} \
              -l ${{ inputs.location }} \
              --capabilities "$TEMPLATE_CAPABILITIES" \
              --configuration-template-file "${{ inputs.template-file }}" \
              --specification "${{ inputs.specification-file }}" \
              --description "$TEMPLATE_DESCRIPTION" \
              --enable-external-validation "$TEMPLATE_ENABLE_VALIDATION" \
              --output json 2>&1)
            
            if [[ $? -eq 0 ]]; then
              TEMPLATES_CREATED=1
              FILES_CREATED=true
              
              # Extract resource IDs and create metadata (same logic as before)
              SOLUTION_TEMPLATE_ID=$(echo "$RESPONSE" | jq -r '.properties.solutionTemplateId // empty')
              SOLUTION_TEMPLATE_VERSION_ID=$(echo "$RESPONSE" | jq -r '.properties.solutionTemplateVersionId // empty')
              
              # Create metadata
              FOLDER_PATH=".pg/apps/${{ inputs.app-name }}/solutions"
              mkdir -p "$FOLDER_PATH"
              YAML_FILE="$FOLDER_PATH/$TEMPLATE_NAME.yaml"
              
              if [[ -f "$YAML_FILE" ]]; then
                EXISTING_VERSION=$(yq eval ".versions[] | select(.version == \"$TEMPLATE_VERSION\") | .version" "$YAML_FILE" 2>/dev/null || echo "")
                if [[ -z "$EXISTING_VERSION" ]]; then
                  yq eval ".versions += [{\"version\": \"$TEMPLATE_VERSION\", \"solutionTemplateVersionId\": \"$SOLUTION_TEMPLATE_VERSION_ID\", \"revisions\": []}]" -i "$YAML_FILE"
                fi
              else
                yq eval -n '.solutionTemplateName = "'"$TEMPLATE_NAME"'"' > "$YAML_FILE"
                yq eval '.solutionTemplateId = "'"$SOLUTION_TEMPLATE_ID"'"' -i "$YAML_FILE"
                yq eval '.versions = []' -i "$YAML_FILE"
                yq eval '.versions += [{"version": "'"$TEMPLATE_VERSION"'", "solutionTemplateVersionId": "'"$SOLUTION_TEMPLATE_VERSION_ID"'", "revisions": []}]' -i "$YAML_FILE"
              fi
              echo "âœ… Created: $TEMPLATE_NAME v$TEMPLATE_VERSION"
            else
              TEMPLATES_FAILED=1
              FAILED_TEMPLATES_DETAILS=$(echo '[]' | jq --arg file "${{ inputs.template-file }}" --arg name "$TEMPLATE_NAME" --arg version "$TEMPLATE_VERSION" --arg error "Azure CLI creation failed" --arg details "$RESPONSE" '. + [{"file": $file, "template-name": $name, "version": $version, "error": $error, "error-details": $details}]')
            fi
          fi
        fi
        
        # Compact JSON arrays for output
        SKIPPED_TEMPLATES_COMPACT=$(echo "$SKIPPED_TEMPLATES_DETAILS" | jq -c .)
        FAILED_TEMPLATES_COMPACT=$(echo "$FAILED_TEMPLATES_DETAILS" | jq -c .)
        
        # Set all outputs
        echo "files_created=$FILES_CREATED" >> $GITHUB_OUTPUT
        echo "templates_skipped=$TEMPLATES_SKIPPED" >> $GITHUB_OUTPUT
        echo "templates_failed=$TEMPLATES_FAILED" >> $GITHUB_OUTPUT
        echo "skipped_templates_details=$SKIPPED_TEMPLATES_COMPACT" >> $GITHUB_OUTPUT
        echo "failed_templates_details=$FAILED_TEMPLATES_COMPACT" >> $GITHUB_OUTPUT
        
        # Summary
        echo ""
        echo "ðŸ“Š Solution Template Processing Summary:"
        echo "   Templates created: $TEMPLATES_CREATED"
        echo "   Templates skipped: $TEMPLATES_SKIPPED"
        echo "   Templates failed: $TEMPLATES_FAILED"
        echo "   Files created: $FILES_CREATED"
